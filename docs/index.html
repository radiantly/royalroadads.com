<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Royal Road Ads</title>
    <style>
      :root {
        --grid-padding: 10px;
        --yellow: #fff54b;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        min-height: 100vh;
      }
      body {
        display: flex;
        justify-content: center;
        color: #111;
        background-color: #fff;
        font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir,
          segoe ui, helvetica neue, Adwaita Sans, Cantarell, Ubuntu, roboto,
          noto, helvetica, arial, sans-serif;
        overflow-x: hidden;
        overflow-y: scroll;
      }
      .yellow {
        color: var(--yellow);
      }
      .container {
        display: flex;
        flex-direction: column;
        padding: 20px;
        gap: 40px;
        width: 100%;
      }
      nav {
        display: flex;
        padding: 20px 25px;
        position: relative;
        justify-content: center;
        z-index: 42;
        font-family: "Dot Matrix";
        border: 1px solid #ebebeb;
        width: 90vw;
        align-self: center;
        border-radius: 10px;
        box-shadow: 0 50px 110px 0 rgba(0, 0, 0, 0.1),
          0 201px 201px 0 rgba(0, 0, 0, 0.09),
          0 452px 250px 0 rgba(0, 0, 0, 0.05),
          0 803px 250px 0 rgba(0, 0, 0, 0.01);
        align-items: center;
        font-size: 1.1rem;
      }
      nav .logo {
        font-size: 24px;
      }

      nav .logo .accent {
        position: relative;
        color: white;
      }

      nav .logo .accent::before {
        content: "";
        position: absolute;
        top: -4px;
        left: -7px;
        width: calc(100% + 10px);
        height: calc(100% + 7px);
        border-radius: 5px;
        background-color: #2a2a2a;
        z-index: -1;
      }

      nav a {
        text-decoration: none;
        color: inherit;
        position: relative;
      }

      nav a::before {
        content: "";
        position: absolute;
        bottom: -4px;
        left: 0;
        width: 100%;
        height: 2px;
        background-color: #2a2a2a;
        transform: scaleX(0);
        transform-origin: left center;
        transition: transform 0.2s ease;
      }

      nav a:hover::before {
        transform: scale(1);
      }

      .rra-grid {
        --x: 0;
        --y: 0;
        --width: 300px;
        --height: 250px;

        display: flex;
        flex-grow: 1;
        gap: var(--grid-padding);
        min-height: 500vh;
        position: relative;
        align-self: stretch;
      }

      .rra-grid div.backdrop-container {
        filter: blur(15px);
        z-index: -1;
        pointer-events: none;
      }

      .rra-grid div.backdrop-container img {
        position: absolute;
        top: 0;
        left: 0;
        border-radius: 10px;
        opacity: 0.7;

        width: var(--width);
        height: var(--height);
        transform: translate(var(--x), var(--y));
      }

      .rra-grid div.backdrop-container img.expanded {
        display: none;
      }

      .rra-grid div.positioned {
        position: absolute;
        top: 0;
        left: 0;

        width: var(--width);
        height: var(--height);
        transform: translate(var(--x), var(--y));
        transition: transform 0.2s ease, box-shadow 2s ease 0.2s,
          border 0.2s ease 0.2s;

        border: 1px solid transparent;

        display: flex;
        gap: 20px;
        z-index: 13;
        border-radius: 10px;
      }

      .rra-grid div.positioned:not(.expanded):hover {
        transform: translate(var(--x), calc(var(--y) - 5px));
      }

      .rra-grid div.positioned > .left {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .rra-grid div.positioned > .left .cover-wrap {
        display: flex;
        position: relative;
        overflow: hidden;
        box-shadow: rgba(0, 0, 0, 0.7) 0px 15px 20px -10px;
        border-radius: 3px 2px 2px 3px;
      }

      .rra-grid div.positioned > .left .cover-wrap::before {
        content: "";
        background: linear-gradient(
          to right,
          rgba(0, 0, 0, 0.5) 2px,
          rgba(255, 255, 255, 0.2) 3px,
          rgba(255, 255, 255, 0.1) 5px,
          transparent 6px 7px,
          rgba(255, 255, 255, 0.1) 8px,
          transparent 12px
        );
        box-shadow: inset -1px 1px 2px rgba(255, 255, 255, 0.3);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .rra-grid div.positioned > .left .cover-wrap img {
        width: 150px;
        height: 225px;
      }

      .rra-grid div.positioned > .left .read-btn {
        display: flex;
        justify-content: center;
        align-items: center;
        text-decoration: none;
        border: none;
        background-color: #337ab7;
        height: 40px;
        color: white;
        font-size: 16px;
        font-weight: 600;
        transition: background-color 0.2s ease;
      }

      .rra-grid div.positioned > .left .read-btn:hover {
        background-color: #2a6ea8;
      }

      .rra-grid div.positioned > .left .ad-wrap {
        border-radius: 10px;
        background-color: #eee;
        display: flex;
      }

      .rra-grid div.positioned:not(.external) > .left .ad-wrap {
        cursor: default;
      }

      .rra-grid div.positioned > .left .ad-wrap img {
        border-radius: 10px;
      }

      .rra-grid div.positioned > .right {
        display: flex;
        flex-direction: column;
        min-width: 0;
        gap: 10px;
      }

      .rra-grid div.positioned > .right .title-row {
        display: flex;
        opacity: 0;
        animation: fade-in 0.2s ease 0.3s forwards;
      }

      .rra-grid div.positioned > .right .title {
        font-family: "Dot Matrix";
        font-size: 22px;
      }

      .rra-grid div.positioned > .right .close {
        cursor: pointer;
        position: relative;
      }

      .rra-grid div.positioned > .right .close::before {
        content: "";
        position: absolute;
        top: -10px;
        left: -10px;
        width: calc(100% + 20px);
        height: calc(100% + 20px);
        opacity: 0.2;
      }

      .rra-grid div.positioned > .right .close svg {
        fill: #ddd;
        transition: fill 0.2s ease;
      }

      .rra-grid div.positioned > .right .close:hover svg {
        fill: #aaa;
      }

      .rra-grid div.positioned > .right .tags-wrap {
        --tag-height: 20px;
        height: var(--tag-height);
        opacity: 0;
        animation: fade-in 0.2s ease 0.4s forwards;
      }

      .rra-grid div.positioned > .right .tags {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
        font-size: 13px;
        text-transform: capitalize;
        color: #666;
        clip-path: polygon(
          0 0,
          100% 0,
          100% var(--tag-height),
          0 var(--tag-height)
        );
        transition: clip-path 0.4s ease;
        padding-bottom: 30px;
      }
      .rra-grid div.positioned > .right .tags-wrap:hover > .tags {
        clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      }

      .rra-grid div.positioned > .right .tags > div {
        flex-shrink: 0;
        border: 1px solid #ddd;
        border-radius: 2px;
        padding: 0 3px;
        height: var(--tag-height);
        display: flex;
        align-items: center;
      }

      .rra-grid div.positioned > .right .summary {
        font-size: 0.9em;
        opacity: 0;
        animation: fade-in 0.3s ease 0.5s forwards;
        display: flex;
        flex-direction: column;
        gap: 10px;
        clip-path: inset(0 0 0 0);
        transition: clip-path 0.5s ease;
      }

      .rra-grid div.positioned > .right .tags-wrap:hover + .summary {
        clip-path: inset(100% 0 0 0);
      }

      .rra-grid div.positioned > .right .summary > p {
        margin: 0;
      }

      .rra-grid div.positioned > .right hr {
        border: none;
        background-color: #ddd;
        height: 2px;
      }

      .rra-grid div.positioned:not(.expanded) .left .cover-wrap,
      .rra-grid div.positioned:not(.expanded) .left .read-btn,
      .rra-grid div.positioned:not(.expanded) .right {
        display: none;
      }

      .rra-grid div.positioned:not(.expanded) .left,
      .rra-grid div.positioned:not(.expanded) .left .ad-wrap {
        flex-grow: 1;
      }

      .rra-grid div.positioned.expanded {
        box-shadow: 0 22px 48px 0 rgba(0, 0, 0, 0.1),
          0 87px 87px 0 rgba(0, 0, 0, 0.09), 0 196px 118px 0 rgba(0, 0, 0, 0.05),
          0 348px 139px 0 rgba(0, 0, 0, 0.01), 0 545px 152px 0 rgba(0, 0, 0, 0);
        border: 1px solid #ebebeb;
        padding: 20px;
      }

      .rra-grid div.positioned.expanded .ad-wrap img {
        width: 150px;
        height: 125px;
        border-radius: 0;
      }
      @keyframes fade-in {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <nav>
        <div class="logo">Royal Road <span class="accent">Ads</span></div>
        <div style="flex-grow: 1"></div>
        <div class="github">
          <a
            href="https://github.com/radiantly/royalroadads.com"
            target="_blank"
            >GITHUB</a
          >
        </div>
      </nav>
      <div class="rra-grid">
        <div class="backdrop-container"></div>
      </div>
    </div>
    <template id="ad-element">
      <div class="positioned">
        <div class="left">
          <div class="cover-wrap">
            <img src="#" />
          </div>
          <a href="#" class="read-btn" target="_blank">Read now</a>
          <a href="#" class="ad-wrap" target="_blank">
            <img src="#" />
          </a>
        </div>
        <div class="right">
          <div class="title-row">
            <div class="title"></div>
            <div style="flex-grow: 1"></div>
            <div class="close">
              <svg
                width="12"
                height="12"
                viewBox="0 0 12 12"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M10.6904 0.0498047C11.0503 0.0498316 11.3431 0.16568 11.5732 0.394531C11.8249 0.646282 11.9502 0.943156 11.9502 1.28809C11.9502 1.5899 11.8547 1.84645 11.6631 2.05957L11.5732 2.14941L7.75781 5.93164L7.72266 5.96777L7.75781 6.00293L11.5732 9.80762C11.802 10.0378 11.917 10.3306 11.917 10.6904C11.917 11.0055 11.8289 11.2691 11.6533 11.4844L11.5732 11.5732C11.3215 11.825 11.0246 11.9501 10.6797 11.9502C10.3348 11.9502 10.0488 11.8255 9.81934 11.5752L9.81836 11.5732L6.03516 7.75781L6 7.72266L5.96484 7.75781L2.16016 11.5732C1.93001 11.8021 1.63711 11.9169 1.27734 11.917C0.917444 11.917 0.623764 11.8021 0.393555 11.5732H0.394531C0.165694 11.3444 0.0498047 11.053 0.0498047 10.6953C0.0498776 10.3378 0.165766 10.0471 0.394531 9.81836L4.20898 6.00293L4.24512 5.9668L4.20898 5.93164L0.393555 2.16016H0.394531C0.165706 1.92998 0.0498595 1.63713 0.0498047 1.27734C0.0498047 0.917476 0.165723 0.624724 0.394531 0.394531C0.623314 0.165748 0.913942 0.0498594 1.27148 0.0498047C1.62914 0.0498047 1.92058 0.165694 2.14941 0.394531L5.96484 4.20898L6 4.24512L6.03516 4.20898L9.80762 0.394531C10.0378 0.165678 10.3306 0.0498047 10.6904 0.0498047Z"
                />
              </svg>
            </div>
          </div>
          <div class="tags-wrap">
            <div class="tags"></div>
          </div>
          <div class="summary"></div>
        </div>
      </div>
      <img class="backdrop" src="#" aria-hidden="true" />
    </template>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
    <script>
      class FictionBuddy {
        static #tagMap = {
          gamelit: "GameLit",
          litrpg: "LitRPG",
          multiple_lead: "Multiple Lead Characters",
          summoned_hero: "Portal Fantasy / Isekai",
        };

        static #dataPromise;
        static #cache = {};
        static {
          setTimeout(() => {
            this.#dataPromise = fetch("fiction.json")
              .then((response) => response.json())
              .then((obj) => obj?.entries ?? {});
          }, 0);
        }

        static #fixupFictionResponse(id, fiction) {
          fiction.id = id;
          fiction.tags = fiction.tags.map(
            (tag) => this.#tagMap[tag] ?? tag.replace(/_/g, " ")
          );
          return fiction;
        }

        static getFictionDetails(fictionId) {
          if (this.#cache.hasOwnProperty(fictionId))
            return this.#cache[fictionId];

          return (this.#cache[fictionId] = this.#dataPromise.then((details) => {
            if (details.hasOwnProperty(fictionId))
              return this.#fixupFictionResponse(fictionId, details[fictionId]);
            return null;
          }));
        }

        static getFictionDetailsFromLink(link) {
          const match = link.match(/royalroad\.com\/fiction\/(\d+)/);
          if (!match) return new Promise((resolve) => resolve(null));
          return FictionBuddy.getFictionDetails(match[1]);
        }
      }

      class RectangleAd {
        static WIDTH = 300;
        static HEIGHT = 250;
        static MIN_WIDTH_EXPANDED = 600;

        #state;
        #current;
        #required;
        constructor(requestLayoutCallback) {
          this.#state = {
            requestLayoutCallback,
            expandable: false,

            // elements
            elements: null,
          };

          this.#current = {
            // layout
            x: null,
            y: null,
            width: null,
            height: null,
            expanded: false,

            // content
            uid: null,
            alt: null,
            link: null,
            fiction: null,
          };

          this.#required = Object.assign({}, this.#current);
        }

        setContent({ uid, alt, link }) {
          /* Assumption: this function is called only once */

          this.#required.uid = uid;
          this.#required.alt = alt;
          this.#required.link = link;
          this.#state.expandable = true;

          FictionBuddy.getFictionDetailsFromLink(link).then((details) => {
            if (details === null) {
              this.#state.expandable = false;
              return;
            }
            this.#required.fiction = details;
            if (this.needsContentUpdate) requestLayoutCallback(this);
          });
        }

        get width() {
          return this.#required.width;
        }
        get height() {
          return this.#required.height;
        }

        get expanded() {
          return this.#required.expanded;
        }

        get elements() {
          if (this.#state.elements === null) {
            this.#state.elements = this.#createHTMLElements();

            const { positioned, backdrop } = this.#state.elements;

            document.querySelector(".rra-grid").appendChild(positioned);
            document
              .querySelector(".rra-grid > .backdrop-container")
              .appendChild(backdrop);
          }
          return this.#state.elements;
        }

        get needsLayoutUpdate() {
          return (
            this.#current.x !== this.#required.x ||
            this.#current.y !== this.#required.y ||
            this.#current.width !== this.#required.width ||
            this.#current.height !== this.#required.height ||
            this.#current.expanded !== this.#required.expanded
          );
        }

        get needsContentUpdate() {
          return (
            this.#current.uid !== this.#required.uid ||
            this.#current.alt !== this.#required.alt ||
            this.#current.link !== this.#required.link ||
            (this.#required.expanded &&
              this.#current.fiction !== this.#required.fiction)
          );
        }

        get expandable() {
          return this.#state.expandable;
        }

        get adImgSrc() {
          return `300x250/${this.#required.uid}.webp`;
        }

        get coverImgSrc() {
          return `200x300/${this.#required.fiction.id}.webp`;
        }

        #addElementHandlers(element, backdrop) {
          element.addEventListener("click", (event) => {
            if (this.#state.expandable === false) return;
            if (event.target.closest(".close")) this.#required.expanded = false;

            if (event.target.closest(".ad-wrap")) {
              event.preventDefault();
              this.#required.expanded = true;
            }

            if (this.#current.expanded !== this.#required.expanded)
              this.#state.requestLayoutCallback(this);
          });
        }

        #markPositionUpdateSuccessful() {
          this.#current.x = this.#required.x;
          this.#current.y = this.#required.y;
          this.#current.width = this.#required.width;
          this.#current.height = this.#required.height;
          this.#current.expanded = this.#required.expanded;
        }

        #markContentUpdateSuccessful() {
          this.#current.uid = this.#required.uid;
          this.#current.alt = this.#required.alt;
          this.#current.link = this.#required.link;
          this.#current.fiction = this.#required.fiction;
        }

        #createHTMLElements() {
          const template = document.getElementById("ad-element");
          const fragment = template.content.cloneNode(true);
          const positioned = fragment.querySelector("div.positioned");

          const backdrop = fragment.querySelector("img.backdrop");

          this.#addElementHandlers(positioned, backdrop);

          return { positioned, backdrop };
        }

        computeHeight({ width }) {
          if (!this.#required.expanded) return RectangleAd.HEIGHT;
          // if (!this.#/) TODO: cache

          const { positioned } = this.elements;

          // set required properties
          positioned.classList.add("expanded");
          positioned.style.setProperty("--width", `${width}px`);
          positioned.style.setProperty("--height", `auto`);

          this.updateContent();

          // calculate height
          const { height } = positioned.getBoundingClientRect();

          // reset properties
          positioned.style.setProperty("--width", `${this.#current.width}px`);
          positioned.style.setProperty("--height", `${this.#current.height}px`);
          positioned.classList.toggle("expanded", this.#current.expanded);

          return Math.ceil(height);
        }

        setLayoutProps({ x, y, width, height, expanded }) {
          this.#required.x = x ?? this.#required.x;
          this.#required.y = y ?? this.#required.y;
          this.#required.width = width ?? this.#required.width;
          this.#required.height = height ?? this.#required.height;
          this.#required.expanded = expanded ?? this.#required.expanded;
        }

        updatePosition() {
          if (!this.needsLayoutUpdate) return;
          const { x, y, width, height, expanded } = this.#required;

          const { positioned, backdrop } = this.elements;
          // gsap.set([positioned, backdrop], { x, y, width, height });
          positioned.style.setProperty("--x", `${x}px`);
          positioned.style.setProperty("--y", `${y}px`);
          positioned.style.setProperty("--width", `${width}px`);
          positioned.style.setProperty("--height", `${height}px`);

          backdrop.style.setProperty("--x", `${x}px`);
          backdrop.style.setProperty("--y", `${y}px`);

          if (expanded !== this.#current.expanded) {
            console.log(width, height);
            positioned.classList.toggle("expanded", expanded);
            backdrop.classList.toggle("expanded", expanded);
          }

          this.#markPositionUpdateSuccessful();
        }

        updateContent() {
          if (!this.needsContentUpdate) return;

          const { positioned, backdrop } = this.elements;
          if (this.#state.expandable === false)
            positioned.classList.add("external");

          positioned.querySelector("a.read-btn").href = this.#required.link;
          positioned.querySelector("a.ad-wrap").href = this.#required.link;

          const img = positioned.querySelector("a.ad-wrap img");
          img.src = this.adImgSrc;
          img.alt = this.#required.alt;
          img.title = this.#required.alt;

          backdrop.src = this.adImgSrc;

          if (this.#required.fiction !== null) {
            const { title, description, tags } = this.#required.fiction;
            const titleElem = positioned.querySelector(".title");
            titleElem.textContent = title;

            const tagsElem = positioned.querySelector(".tags");
            const tagsElems = tags.map((tag) => {
              const div = document.createElement("div");
              div.textContent = tag;
              return div;
            });
            tagsElem.replaceChildren(...tagsElems);

            const summaryElem = positioned.querySelector(".summary");
            summaryElem.innerHTML = description;

            const coverImageElem = positioned.querySelector(".cover-wrap img");
            coverImageElem.src = this.coverImgSrc;
          }
          this.#markContentUpdateSuccessful();
        }
      }

      class RenderMonkey {
        #state;
        constructor() {
          this.#state = {
            ads: [],
            layoutComputedTill: { y: 0, index: 0 },

            varianceCache: new Map(),

            placeholderEntriesCount: 0,

            layoutPending: false,
            activeAd: null,

            vWidth: null,
            vHeight: null,
            scrollY: null,
          };

          this.requestRender = this.requestRender.bind(this);
        }

        addPlaceholderEntries(count) {
          this.#state.placeholderEntriesCount += count;
          for (let i = 0; i < count; i += 1) {
            const ad = new RectangleAd(this.requestRender);
            this.#state.ads.push(ad);
          }
        }

        addAdEntries(entries) {
          for (const [uid, entry] of Object.entries(entries)) {
            if (this.#state.placeholderEntriesCount) {
              const index =
                this.#state.ads.length - this.#state.placeholderEntriesCount;
              this.#state.placeholderEntriesCount -= 1;
              this.#state.ads[index].setContent({ uid, ...entry });
            } else {
              const ad = new RectangleAd(this.requestRender);
              ad.setContent({ uid, ...entry });
              this.#state.ads.push(ad);
            }
          }
        }

        #getVariances(count, variance) {
          if (!this.#state.varianceCache.has(variance))
            this.#state.varianceCache.set(variance, []);

          const variances = this.#state.varianceCache.get(variance);
          const missing = count - variances.length;
          for (let i = 0; i < missing; i += 1) {
            const vx = Math.floor(Math.random() * variance);
            const vy = Math.floor(Math.random() * variance);
            variances.push({ vx, vy });
          }
          return variances;
        }

        #calcMaxAdsForWidth(adWidth, gap, totWidth) {
          // Let x be the number of ads that can be fit in totWidth
          // adWidth * x + gap * (x - 1) = totWidth
          // adWidth * x + gap * x - gap = totWidth
          // x * (adWidth + gap) = totWidth + gap
          // x = (totWidth + gap) / (adWidth + gap)
          return Math.floor((totWidth + gap) / (adWidth + gap));
        }

        computeLayout() {
          const { vWidth, vHeight, scrollY, activeAd } = this.#state;
          const gap = 10;
          const variance = 40; // TODO: make this dynamic based on vWidth or perRow
          const adWidth = RectangleAd.WIDTH + variance;
          const adHeight = RectangleAd.HEIGHT + variance;

          // Ads

          const n = this.#state.ads.length;
          const variances = this.#getVariances(n, variance);

          // iterator
          const it = {
            y: 0,
            index: 0,
          };

          console.log(n, variances);
          let adsInLastRow = 0;
          let side = null;
          let lastSideOnRight = true;
          while (it.index < n) {
            let continueFlag = false;

            // if there was a side but is now over
            if (side && side.tillY < it.y) side = null;

            // don't compute layout for things that are very far from the viewport
            // TODO: fix for mobile
            if (side === null && it.y > scrollY + vHeight * 5) break;

            // if the ad is expanded, we want
            if (this.#state.ads[it.index].expanded) {
              console.log(it.index, "is expanded");
              const ad = this.#state.ads[it.index];
              if (side === null) {
                // calculate the available width
                const avWidth =
                  vWidth - (RectangleAd.MIN_WIDTH_EXPANDED + variance + gap);

                const adsInRow = this.#calcMaxAdsForWidth(
                  adWidth,
                  gap,
                  avWidth
                );
                const extraSpace =
                  avWidth - (adWidth * adsInRow + gap * (adsInRow - 1));

                // ead = expanded ad
                const eadWidth = RectangleAd.MIN_WIDTH_EXPANDED + extraSpace;
                const eadHeight = ad.computeHeight({ width: eadWidth });

                const { vx, vy } = variances[it.index];
                side = {
                  onRight: !lastSideOnRight,
                  width: eadWidth + variance + gap,
                  height: eadHeight + variance + gap,
                  tillY: eadHeight + vy + gap + it.y,
                  it: Object.assign({}, it),
                };
                lastSideOnRight = side.onRight;
                const x = side.onRight ? vWidth - side.width + gap + vx : vx;
                const y = vy + it.y;
                this.#state.ads[it.index].setLayoutProps({
                  x,
                  y,
                  width: eadWidth,
                  height: eadHeight,
                  expanded: true,
                });
                console.log("side", side);
                it.index += 1;
              }
            }

            const avWidth = vWidth - (side?.width ?? 0); // available width
            const adsInRow = this.#calcMaxAdsForWidth(adWidth, gap, avWidth);
            const adsInThisRow = Math.max(
              side == null,
              adsInRow - (adsInRow === adsInLastRow)
            );
            adsInLastRow = adsInThisRow;
            const startX =
              Math.floor(
                (avWidth -
                  (adWidth * adsInThisRow + gap * (adsInThisRow - 1))) /
                  2
              ) + (side?.onRight === false ? side.width : 0);
            for (let j = 0; j < adsInThisRow && it.index < n; j += 1) {
              const ad = this.#state.ads[it.index];
              if (ad.expanded) {
                if (side === null) {
                  const startIndex = it.index - j;
                  [this.#state.ads[startIndex], this.#state.ads[it.index]] = [
                    ad,
                    this.#state.ads[startIndex],
                  ];
                  it.index = startIndex;
                  continueFlag = true;
                  break;
                } else {
                  const sideAd = this.#state.ads[side.it.index];
                  // confirm that the ad that's already on the side is not the active ad.
                  // active ad == ad that triggered this layout (eg, by click)
                  if (sideAd !== activeAd) {
                    sideAd.setLayoutProps({
                      expanded: false,
                    });
                    [it.y, it.index] = [side.it.y, side.it.index];
                    lastSideOnRight = !lastSideOnRight;
                    side = null;
                    continueFlag = true;
                    break;
                  }
                }
              }
              const { vx, vy } = variances[it.index];
              ad.setLayoutProps({
                x: vx + startX + j * (adWidth + gap),
                y: vy + it.y,
                width: 300,
                height: 250,
                expanded: false,
              });
              it.index += 1;
            }
            if (continueFlag) continue;

            // expand random stories
            // TODO: layout request needed when fiction is loaded. See note above
            // if (
            //   side === null &&
            //   it.index < n &&
            //   this.#state.ads[it.index].expandable
            // )
            //   this.#state.ads[it.index].setLayoutProps({
            //     expanded: true,
            //   });

            it.y += adHeight + gap;
          }

          this.#state.layoutComputedTill = it;
        }

        updatePositions() {
          const till = Math.min(
            this.#state.layoutComputedTill.index,
            this.#state.ads.length
          );
          for (let i = 0; i < till; i += 1) {
            const ad = this.#state.ads[i];
            ad.updatePosition();
            ad.updateContent();
          }
        }

        render() {
          this.#state.vWidth = document.querySelector(".rra-grid").clientWidth;
          this.#state.vHeight = window.innerHeight;
          this.#state.scrollY = window.scrollY;
          console.info("COMPUTING LAYOUT");

          this.computeLayout();
          this.updatePositions();

          console.log(this.#state.layoutComputedTill);

          this.#state.layoutPending = false;
          this.#state.activeAd = null;
        }

        requestRender(requestingAd = null) {
          if (requestingAd) this.#state.activeAd = requestingAd;
          if (this.#state.layoutPending) return;
          this.#state.layoutPending = true;
          requestAnimationFrame(() => this.render());
        }

        requestRenderOnScroll() {
          if (
            this.#state.layoutComputedTill.y >
            window.scrollY + this.#state.vHeight * 3
          )
            return;
          if (this.#state.layoutComputedTill.index === this.#state.ads.length)
            return;
          this.requestRender();
        }
      }

      const renderMonkey = new RenderMonkey();
      renderMonkey.addPlaceholderEntries(13);
      renderMonkey.requestRender();

      const handleData = ({ entries }) => {
        renderMonkey.addAdEntries(entries);
        renderMonkey.requestRender();

        window.addEventListener("resize", () => renderMonkey.requestRender(), {
          passive: true,
        });
        window.addEventListener(
          "scroll",
          () => renderMonkey.requestRenderOnScroll(),
          { passive: true }
        );
      };

      fetch("300x250/entries.json")
        .then((response) => response.json())
        .then(handleData);
    </script>
  </body>
</html>
