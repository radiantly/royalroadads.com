<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Royal Road Ads</title>
    <style>
      :root {
        --grid-padding: 10px;
        --yellow: #fff54b;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        min-height: 100vh;
      }
      body {
        display: flex;
        justify-content: center;
        color: #111;
        background-color: #fff;
        font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir,
          segoe ui, helvetica neue, Adwaita Sans, Cantarell, Ubuntu, roboto,
          noto, helvetica, arial, sans-serif;
        overflow-x: hidden;
        overflow-y: scroll;
      }
      .yellow {
        color: var(--yellow);
      }
      .container {
        display: flex;
        flex-direction: column;
        padding: 20px;
        gap: 40px;
        width: 100%;
      }
      nav {
        display: flex;
        padding: 20px 25px;
        position: relative;
        justify-content: center;
        z-index: 42;
        font-family: "Dot Matrix";
        border: 1px solid #ebebeb;
        width: 90vw;
        align-self: center;
        border-radius: 10px;
        box-shadow: 0 50px 110px 0 rgba(0, 0, 0, 0.1),
          0 201px 201px 0 rgba(0, 0, 0, 0.09),
          0 452px 250px 0 rgba(0, 0, 0, 0.05),
          0 803px 250px 0 rgba(0, 0, 0, 0.01);
        align-items: center;
        font-size: 1.1rem;
      }
      nav .logo {
        font-size: 24px;
      }

      nav .logo .accent {
        position: relative;
        color: white;
      }

      nav .logo .accent::before {
        content: "";
        position: absolute;
        top: -4px;
        left: -7px;
        width: calc(100% + 10px);
        height: calc(100% + 7px);
        border-radius: 5px;
        background-color: #2a2a2a;
        z-index: -1;
      }

      nav a {
        text-decoration: none;
        color: inherit;
        position: relative;
      }

      nav a::before {
        content: "";
        position: absolute;
        bottom: -4px;
        left: 0;
        width: 100%;
        height: 2px;
        background-color: #2a2a2a;
        transform: scaleX(0);
        transform-origin: left center;
        transition: transform 0.2s ease;
      }

      nav a:hover::before {
        transform: scale(1);
      }

      .rra-grid {
        --x: 0;
        --y: 0;
        --width: 300px;
        --height: 250px;

        display: flex;
        flex-grow: 1;
        gap: var(--grid-padding);
        min-height: 500vh;
        position: relative;
        align-self: stretch;
      }

      .rra-grid div.backdrop-container {
        filter: blur(15px);
        z-index: -1;
        pointer-events: none;
      }

      .rra-grid div.backdrop-container img {
        position: absolute;
        top: 0;
        left: 0;
        border-radius: 10px;
        opacity: 0.7;

        width: var(--width);
        height: var(--height);
        transform: translate(var(--x), var(--y));
      }

      .rra-grid div.backdrop-container img.expanded {
        display: none;
      }

      .rra-grid div.positioned {
        position: absolute;
        top: 0;
        left: 0;

        width: var(--width);
        height: var(--height);
        transform: translate(var(--x), var(--y));
        transition: transform 0.2s ease;

        display: flex;
        gap: 20px;
        z-index: 13;
        border-radius: 10px;
      }

      .rra-grid div.positioned:not(.expanded):hover {
        transform: translate(var(--x), calc(var(--y) - 5px));
      }

      .rra-grid div.positioned a {
        display: flex;
      }

      .rra-grid div.positioned > .left {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .rra-grid div.positioned > .left .cover-wrap {
        display: flex;
        position: relative;
        border-radius: 2px;
        overflow: hidden;
        box-shadow: 0 0 5px -1px rgba(0, 0, 0, 0.7);
      }

      .rra-grid div.positioned > .left .cover-wrap::before {
        content: "";
        background: linear-gradient(
          to right,
          rgba(0, 0, 0, 0.5) 2px,
          rgba(255, 255, 255, 0.2) 3px,
          rgba(255, 255, 255, 0.1) 5px,
          transparent 6px,
          transparent 7px,
          rgba(255, 255, 255, 0.1) 8px,
          transparent 12px
        );
        box-shadow: inset -1px 1px 2px rgba(255, 255, 255, 0.3);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .rra-grid div.positioned > .left .cover-wrap img {
        width: 150px;
        height: 225px;
      }

      .rra-grid div.positioned > .left .read-btn {
        display: flex;
        justify-content: center;
        align-items: center;
        text-decoration: none;
        border: none;
        background-color: #337ab7;
        height: 40px;
        color: white;
        font-size: 16px;
        font-weight: 600;
        transition: background-color 0.2s ease;
      }

      .rra-grid div.positioned > .left .read-btn:hover {
        background-color: #2a6ea8;
      }

      .rra-grid div.positioned > .left .ad-wrap img {
        border-radius: 10px;
      }

      .rra-grid div.positioned:not(.external) > .left .ad-wrap {
        cursor: default;
      }

      .rra-grid div.positioned > .right {
        display: flex;
        flex-direction: column;
        min-width: 0;
      }

      .rra-grid div.positioned > .right .title {
        font-family: "Dot Matrix";
        font-size: 22px;
      }

      .rra-grid div.positioned > .right .summary {
        font-size: 0.9em;
      }

      .rra-grid div.positioned:not(.expanded) .left .cover-wrap,
      .rra-grid div.positioned:not(.expanded) .left .read-btn,
      .rra-grid div.positioned:not(.expanded) .right {
        display: none;
      }

      .rra-grid div.positioned.expanded {
        box-shadow: 0 22px 48px 0 rgba(0, 0, 0, 0.1),
          0 87px 87px 0 rgba(0, 0, 0, 0.09), 0 196px 118px 0 rgba(0, 0, 0, 0.05),
          0 348px 139px 0 rgba(0, 0, 0, 0.01), 0 545px 152px 0 rgba(0, 0, 0, 0);
        border: 1px solid #ebebeb;
        padding: 20px;
      }

      .rra-grid div.positioned.expanded .ad-wrap img {
        width: 150px;
        height: 125px;
        border-radius: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <nav>
        <div class="logo">Royal Road <span class="accent">Ads</span></div>
        <div style="flex-grow: 1"></div>
        <div class="github">
          <a
            href="https://github.com/radiantly/royalroadads.com"
            target="_blank"
            >GITHUB</a
          >
        </div>
      </nav>
      <div class="rra-grid">
        <div class="backdrop-container"></div>
      </div>
    </div>
    <template id="ad-element">
      <div class="positioned">
        <div class="left">
          <div class="cover-wrap">
            <img src="#" />
          </div>
          <a href="#" class="read-btn">Read now</a>
          <a href="#" class="ad-wrap" target="_blank">
            <img src="#" />
          </a>
        </div>
        <div class="right">
          <div class="title-row">
            <div class="title">
              The Phoenix [Cultivation, Reincarnation, Tower Climber]
            </div>
            <div class="close"></div>
          </div>
          <div class="summary">
            <p>
              <strong
                ><span
                  >She entered the Tower seeking death. Instead, she keeps
                  finding reasons to live.</span
                ></strong
              ><span> </span>
            </p>
            <p>
              <span
                >In this life, she's Bella, a jaded med student trying to catch
                up on centuries of medical innovation. Or at least, she was
                before the Tower appeared. With the promise that she would find
                whatever she sought if she reached the top, she entered, hoping
                to find a way to end her curse.
              </span>
            </p>
            <p>
              <span
                >However, even with hundreds of lives of experience to fall back
                on, reaching the top is no easy task. The Tower is filled with
                wonders she could only dream of, and w</span
              ><span
                >hat she once believed was the peak of power was only the first
                rung of a much larger climb. Her foundations are unshakable, but
                the Tower is deeper, deadlier, and more </span
              ><em><span>exhilarating</span></em
              ><span> than anything she’s ever faced.</span>
            </p>
            <p>
              <span
                >And when she finally reaches the top? She’ll decide whether to
                end it all… or maybe not.</span
              >
            </p>
            <p>
              <span style="text-decoration: underline"
                ><strong>Inspired by:</strong></span
              >
            </p>
            <p>
              - Tower of God<br />- Hunter X Hunter<br />- Hell Difficulty
              Tutorial<br />- Various Murim and Xianxia stories
            </p>
            <p>
              <span style="text-decoration: underline"
                ><strong>What to expect</strong></span
              >
            </p>
            <p>
              <span style="text-decoration: underline"></span>- Strong to
              Stronger<br />- Magic system is Hunter X Hunter + cultivation<br />-
              A Tower of massive scale with many different places and races<br />-
              No romance<br />- Tournament Arc!<br />- Long-term character
              development<br />- A cat (?)
            </p>
          </div>
        </div>
      </div>
      <img class="backdrop" src="#" aria-hidden="true" />
    </template>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
    <script>
      class FictionBuddy {
        static #dataPromise;
        static {
          this.#dataPromise = fetch("fiction.json")
            .then((response) => response.json())
            .then((obj) => obj?.entries ?? {});
        }

        static getFictionDetails(fictionId) {
          return this.#dataPromise.then((deets) => {
            if (deets.hasOwnProperty(fictionId))
              return { id: fictionId, ...deets[fictionId] };
            return null;
          });
        }

        static getFictionDetailsFromLink(link) {
          const match = link.match(/royalroad\.com\/fiction\/(\d+)/);
          if (!match) return new Promise((resolve) => resolve(null));
          return FictionBuddy.getFictionDetails(match[1]);
        }
      }

      class RectangleAd {
        static WIDTH = 300;
        static HEIGHT = 250;
        static MIN_WIDTH_EXPANDED = 600;

        #state;
        #current;
        #required;
        constructor(uid, alt, link, requestLayoutCallback) {
          this.#state = {
            requestLayoutCallback,
            expandable: true,
            fiction: null,

            // elements
            elements: null,

            // animations
            hoverTween: {
              cached: null,
              position: null,
            },
          };

          this.#current = {
            // layout
            x: null,
            y: null,
            width: null,
            height: null,
            expanded: false,

            // content
            uid: null,
            alt: null,
            link: null,
          };

          this.#required = {
            // layout
            x: null,
            y: null,
            width: null,
            height: null,
            expanded: false,

            // content
            uid,
            alt,
            link,
          };

          FictionBuddy.getFictionDetailsFromLink(link).then((details) => {
            if (details === null) {
              this.#state.expandable = false;
              return;
            }
            this.#state.fiction = details;
          });
        }

        get width() {
          return this.#required.width;
        }
        get height() {
          // return this.#state.expanded ? 730 : RectangleAd.HEIGHT;
          return this.#required.height;
        }

        get content() {
          return {
            uid: this.#required.uid,
            alt: this.#required.alt,
            link: this.#required.link,
          };
        }

        get expanded() {
          return this.#required.expanded;
        }

        get elements() {
          if (this.#state.elements === null) {
            this.#state.elements = this.#createHTMLElements();

            const { positioned, backdrop } = this.#state.elements;

            document.querySelector(".rra-grid").appendChild(positioned);
            document
              .querySelector(".rra-grid > .backdrop-container")
              .appendChild(backdrop);
          }
          return this.#state.elements;
        }

        get needsLayoutUpdate() {
          return (
            this.#current.x !== this.#required.x ||
            this.#current.y !== this.#required.y ||
            this.#current.width !== this.#required.width ||
            this.#current.height !== this.#required.height ||
            this.#current.expanded !== this.#required.expanded
          );
        }

        get needsContentUpdate() {
          return (
            this.#current.uid !== this.#required.uid ||
            this.#current.alt !== this.#required.alt ||
            this.#current.link !== this.#required.link
          );
        }

        get hoverTween() {
          if (
            this.#state.hoverTween.position?.x === this.#current.x &&
            this.#state.hoverTween.position?.y === this.#current.y
          ) {
            return this.#state.hoverTween.cached;
          }

          const { positioned, backdrop } = this.#state.elements;

          this.#state.hoverTween.cached?.kill();
          const timeline = gsap.timeline();
          timeline.to(
            positioned,
            {
              y: this.#current.y - 5,
              duration: 0.2,
            },
            0
          );

          this.#state.hoverTween = {
            cached: timeline,
            position: { x: this.#current.x, y: this.#current.y },
          };
          return timeline;
        }

        get fictionId() {
          const match = this.#required.link.match(
            /royalroad\.com\/fiction\/(\d+)/
          );
          return match ? match[1] : null;
        }

        get adImgSrc() {
          return `300x250/${this.#required.uid}.webp`;
        }

        get coverImgSrc() {
          return `200x300/${this.#state.fiction.id}.webp`;
        }

        #addElementHandlers(element, backdrop) {
          // const mouseenterHandler = () => {
          //   console.log(this.#state.fictionId, "entered");
          //   this.hoverTween.play();
          // };
          // const mouseleaveHandler = () => {
          //   console.log(this.#state.fictionId, "left");
          //   this.hoverTween.reverse();
          // };
          // gsap.set(backdrop, { opacity: 0.6 });
          // element.addEventListener("mouseenter", mouseenterHandler);
          // element.addEventListener("mouseleave", mouseleaveHandler);
          element.addEventListener("click", (event) => {
            if (this.#state.expandable === false) return;
            event.preventDefault();
            this.#required.expanded = !this.#required.expanded;
            this.#state.requestLayoutCallback();
          });
        }

        #markSetContentSuccessful() {
          this.#current.uid = this.#required.uid;
          this.#current.alt = this.#required.alt;
          this.#current.link = this.#required.link;
        }

        #createHTMLElements() {
          const template = document.getElementById("ad-element");
          const fragment = template.content.cloneNode(true);
          const positioned = fragment.querySelector("div.positioned");
          if (this.#state.expanded) positioned.classList.add("expanded");
          if (this.#state.expandable === false)
            positioned.classList.add("external");

          positioned.querySelector("a.read-btn").href = this.#required.link;
          positioned.querySelector("a.ad-wrap").href = this.#required.link;

          const img = positioned.querySelector("a.ad-wrap img");
          img.src = this.adImgSrc;
          img.alt = this.#required.alt;
          img.title = this.#required.alt;

          const backdrop = fragment.querySelector("img.backdrop");
          backdrop.src = this.adImgSrc;
          this.#addElementHandlers(positioned, backdrop);

          if (this.#state.fiction !== null) {
            const { title, description } = this.#state.fiction;
            const titleElem = positioned.querySelector(".title");
            titleElem.textContent = title;

            const summaryElem = positioned.querySelector(".summary");
            summaryElem.innerHTML = description;

            const coverImageElem = positioned.querySelector(".cover-wrap img");
            coverImageElem.src = this.coverImgSrc;
          }

          this.#markSetContentSuccessful();

          return { positioned, backdrop };
        }

        setLayoutProps({ x, y, width, height, expanded }) {
          this.#required.x = x ?? this.#required.x;
          this.#required.y = y ?? this.#required.y;
          this.#required.width = width ?? this.#required.width;
          this.#required.height = height ?? this.#required.height;
          this.#required.expanded = expanded ?? this.#required.expanded;
        }

        setContent({ uid, alt, link }) {
          this.#required.uid = uid ?? this.#required.uid;
          this.#required.alt = alt ?? this.#required.alt;
          this.#required.link = link ?? this.#required.link;
        }

        swapContent(rectangleAd) {
          const tmp = rectangleAd.content;
          rectangleAd.setContent(this.content);
          this.setContent(tmp);
        }

        updatePosition() {
          if (!this.needsLayoutUpdate) return;
          const { x, y, width, height, expanded } = this.#required;

          const { positioned, backdrop } = this.elements;
          // gsap.set([positioned, backdrop], { x, y, width, height });
          positioned.style.setProperty("--x", `${x}px`);
          positioned.style.setProperty("--y", `${y}px`);
          positioned.style.setProperty("--width", `${width}px`);
          positioned.style.setProperty("--height", `${height}px`);

          backdrop.style.setProperty("--x", `${x}px`);
          backdrop.style.setProperty("--y", `${y}px`);

          if (expanded !== this.#current.expanded) {
            console.log(width, height);
            positioned.classList.toggle("expanded", expanded);
            backdrop.classList.toggle("expanded", expanded);
          }

          this.#current = { x, y, width, height, expanded };
        }

        updateContent() {
          if (!this.needsContentUpdate) return;

          const { positioned } = this.elements;
          positioned.querySelector("a.ad-wrap").href = this.#required.link;

          const img = positioned.querySelector("a.ad-wrap img");
          img.src = this.adImgSrc;
          img.alt = this.#required.alt;
          img.title = this.#required.alt;
          this.#markSetContentSuccessful();
        }
      }

      class RenderMonkey {
        #state;
        constructor() {
          this.#state = {
            ads: [],
            layoutComputedTill: 0,

            varianceCache: new Map(),
          };
        }

        addAdEntries(entries) {
          const requestLayoutCallback = () => {
            this.computeLayout(
              document.querySelector(".rra-grid").clientWidth,
              window.innerHeight,
              window.scrollY
            );
            this.updatePositions();
          };
          for (const [uid, entry] of Object.entries(entries))
            this.#state.ads.push(
              new RectangleAd(uid, entry.alt, entry.link, requestLayoutCallback)
            );
          // this.#state.ads[4].setLayoutProps({ expanded: true });
        }

        #getVariances(count, variance) {
          if (!this.#state.varianceCache.has(variance))
            this.#state.varianceCache.set(variance, []);

          const variances = this.#state.varianceCache.get(variance);
          const missing = count - variances.length;
          for (let i = 0; i < missing; i += 1) {
            const vx = Math.floor(Math.random() * variance);
            const vy = Math.floor(Math.random() * variance);
            variances.push({ vx, vy });
          }
          return variances;
        }

        #calcMaxAdsForWidth(adWidth, gap, totWidth) {
          // Let x be the number of ads that can be fit in totWidth
          // adWidth * x + gap * (x - 1) = totWidth
          // adWidth * x + gap * x - gap = totWidth
          // x * (adWidth + gap) = totWidth + gap
          // x = (totWidth + gap) / (adWidth + gap)
          return Math.floor((totWidth + gap) / (adWidth + gap));
        }

        computeLayout(vWidth, vHeight, scrollY) {
          const gap = 10;
          const variance = 40; // TODO: make this dynamic based on vWidth or perRow
          const adWidth = RectangleAd.WIDTH + variance;
          const adHeight = RectangleAd.HEIGHT + variance;

          // Ads

          const n = this.#state.ads.length;
          const variances = this.#getVariances(n, variance);

          // iterator
          const it = {
            y: 0,
            index: 0,
          };

          console.log(n, variances);
          let adsInLastRow = 0;
          let side = null;
          let last_side_position = "right";
          while (it.index < n) {
            let continueFlag = false;

            // if there was a side but is now over
            if (side && side.tillY < it.y) side = null;

            // don't compute layout for things that are very far from the viewport
            // TODO: fix for mobile
            // if (side === null && it.y > scrollY + vHeight * 5) break;

            // if the ad is expanded, we want
            if (this.#state.ads[it.index].expanded) {
              console.log(it.index, "is expanded");
              const ad = this.#state.ads[it.index];
              if (side === null) {
                // calculate the available width
                const avWidth =
                  vWidth - (RectangleAd.MIN_WIDTH_EXPANDED + variance + gap);

                const adsInRow = this.#calcMaxAdsForWidth(
                  adWidth,
                  gap,
                  avWidth
                );
                const extraSpace =
                  avWidth - (adWidth * adsInRow + gap * (adsInRow - 1));

                // ead = expanded ad
                const eadWidth = RectangleAd.MIN_WIDTH_EXPANDED + extraSpace;
                const eadHeight = 730;

                const { vx, vy } = variances[it.index];
                side = {
                  position: last_side_position === "right" ? "left" : "right",
                  width: eadWidth + variance + gap,
                  height: eadHeight + variance + gap,
                  tillY: eadHeight + vy + gap + it.y,
                  it: Object.assign({}, it),
                };
                last_side_position = side.position;
                const x =
                  side.position === "left"
                    ? vx
                    : vWidth - side.width + gap + vx;
                const y = vy + it.y;
                this.#state.ads[it.index].setLayoutProps({
                  x,
                  y,
                  width: eadWidth,
                  height: eadHeight,
                  expanded: true,
                });
                console.log("side", side);
                it.index += 1;
              } else {
                // if side already exists but this is also expanded
                // handle this
              }
            }

            const avWidth = vWidth - (side?.width ?? 0); // available width
            const adsInRow = this.#calcMaxAdsForWidth(adWidth, gap, avWidth);
            const adsInThisRow = Math.max(
              1,
              adsInRow - (adsInRow === adsInLastRow)
            );
            adsInLastRow = adsInThisRow;
            const startX =
              Math.floor(
                (avWidth -
                  (adWidth * adsInThisRow + gap * (adsInThisRow - 1))) /
                  2
              ) + (side?.position === "left" ? side.width : 0);
            for (let j = 0; j < adsInThisRow && it.index < n; j += 1) {
              const ad = this.#state.ads[it.index];
              if (ad.expanded) {
                if (side === null) {
                  const startIndex = it.index - j;
                  [this.#state.ads[startIndex], this.#state.ads[it.index]] = [
                    ad,
                    this.#state.ads[startIndex],
                  ];
                  it.index = startIndex;
                  continueFlag = true;
                  break;
                } else {
                  ad.swapContent(this.#state.ads[side.it.index]);
                }
              }
              const { vx, vy } = variances[it.index];
              ad.setLayoutProps({
                x: vx + startX + j * (adWidth + gap),
                y: vy + it.y,
                width: 300,
                height: 250,
                expanded: false,
              });
              it.index += 1;
            }
            if (continueFlag) continue;
            it.y += adHeight + gap;
          }

          this.layoutComputedTill = it.index;
        }

        updatePositions(vWidth, vHeight, scrollY) {
          const till = Math.min(
            this.layoutComputedTill,
            this.#state.ads.length
          );
          for (let i = 0; i < till; i += 1) {
            const ad = this.#state.ads[i];
            ad.updatePosition();
            ad.updateContent();
          }
        }
      }

      let lastViewportWidth = null;
      let lastViewportHeight = null;
      let lastScrollY = null;
      const renderMonkey = new RenderMonkey();
      const loop = () => {
        const viewportWidth = document.querySelector(".rra-grid").clientWidth;
        const viewportHeight = window.innerHeight;
        const scrollY = window.scrollY;

        // requestAnimationFrame(loop);

        if (
          viewportWidth === lastViewportWidth &&
          viewportHeight === lastViewportHeight &&
          scrollY === lastScrollY
        )
          return;

        lastViewportWidth = viewportWidth;
        lastViewportHeight = viewportHeight;
        lastScrollY = scrollY;
        renderMonkey.computeLayout(viewportWidth, viewportHeight, scrollY);
        renderMonkey.updatePositions(viewportWidth, viewportHeight, scrollY);
      };

      const handleData = ({ entries }) => {
        renderMonkey.addAdEntries(entries);
        requestAnimationFrame(loop);

        window.addEventListener("resize", loop);
      };

      fetch("300x250/entries.json")
        .then((response) => response.json())
        .then(handleData);
    </script>
  </body>
</html>
