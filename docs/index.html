<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Royal Road Ads</title>
    <style>
      :root {
        --grid-padding: 10px;
        --yellow: #fff54b;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        min-height: 100vh;
      }
      body {
        display: flex;
        justify-content: center;
        color: #111;
        background-color: #fff;
        font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir,
          segoe ui, helvetica neue, Adwaita Sans, Cantarell, Ubuntu, roboto,
          noto, helvetica, arial, sans-serif;
        overflow-x: hidden;
        overflow-y: scroll;
      }
      .yellow {
        color: var(--yellow);
      }
      .container {
        display: flex;
        flex-direction: column;
        padding: 20px;
        gap: 20px;
        width: 100%;
      }
      nav {
        display: flex;
        padding: 24px 0;
        position: relative;
        justify-content: center;
        z-index: 42;
        font-family: "Dot Matrix";
        border: 1px solid #ebebeb;
        width: 90vw;
        align-self: center;
      }
      nav .logo {
        font-size: 24px;
      }
      .rra-grid {
        display: flex;
        flex-grow: 1;
        gap: var(--grid-padding);
        min-height: 500vh;
        position: relative;
        align-self: stretch;
      }
      .rra-grid div.positioned {
        position: absolute;
        top: 0;
        left: 0;

        display: flex;
        gap: 20px;
        z-index: 13;
        border-radius: 10px;
      }

      .rra-grid div.positioned a {
        display: flex;
      }

      .rra-grid div.positioned > .left {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .rra-grid div.positioned > .left .cover-wrap img {
        width: 150px;
        height: 225px;
      }

      .rra-grid div.positioned > .left .read-btn {
        border: none;
        background-color: #337ab7;
        height: 40px;
        color: white;
        font-size: 16px;
        font-weight: 600;
      }

      .rra-grid div.positioned > .left .ad-wrap img {
        border-radius: 10px;
      }

      .rra-grid div.positioned > .right {
        display: flex;
        flex-direction: column;
        min-width: 0;
      }

      .rra-grid div.positioned > .right .title {
        font-family: "Dot Matrix";
        font-size: 20px;
      }

      .rra-grid div.positioned > .right .summary {
        font-size: 0.9em;
      }

      .rra-grid div.positioned:not(.expanded) .left .cover-wrap,
      .rra-grid div.positioned:not(.expanded) .left .read-btn,
      .rra-grid div.positioned:not(.expanded) .right {
        display: none;
      }

      .rra-grid div.positioned.expanded {
        width: 600px;
        min-height: 730px;
        box-shadow: 0 22px 48px 0 rgba(0, 0, 0, 0.1),
          0 87px 87px 0 rgba(0, 0, 0, 0.09), 0 196px 118px 0 rgba(0, 0, 0, 0.05),
          0 348px 139px 0 rgba(0, 0, 0, 0.01), 0 545px 152px 0 rgba(0, 0, 0, 0);
        border: 1px solid #ebebeb;
        padding: 20px;
      }

      .rra-grid div.positioned.expanded .ad-wrap img {
        width: 150px;
        height: 100px;
        border-radius: 0;
      }

      /* .rra-grid div.positioned a div.backdrop {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        opacity: 0;
        transition: opacity 0.5s ease;
        pointer-events: none;
      } */

      /* .rra-grid div.positioned a:hover div.backdrop {
        opacity: 1;
      }

      .rra-grid div.positioned a div.backdrop::before {
        content: "";
        position: absolute;
        top: -15%;
        left: -15%;
        bottom: -15%;
        right: -15%;
        backdrop-filter: blur(15px);
      } */
      /* .rra-grid div.positioned a img {
        position: relative;
        z-index: 42;
        width: 300px;
        height: 250px;
      } */
    </style>
  </head>
  <body>
    <div class="container">
      <nav>
        <div class="logo">Royal Road <span class="yellow">Ads</span></div>
      </nav>
      <div class="rra-grid"></div>
    </div>
    <div class="hidden">
      <div class="template"></div>
    </div>
    <template id="ad-element">
      <div class="positioned">
        <div class="left">
          <div class="cover-wrap">
            <img src="#" />
          </div>
          <button class="read-btn">Read now</button>
          <a href="#" class="ad-wrap" target="_blank">
            <img src="#" />
          </a>
        </div>
        <div class="right">
          <div class="title-row">
            <div class="title">
              The Phoenix [Cultivation, Reincarnation, Tower Climber]
            </div>
            <div class="close"></div>
          </div>
          <div class="summary">
            <p>
              <strong
                ><span
                  >She entered the Tower seeking death. Instead, she keeps
                  finding reasons to live.</span
                ></strong
              ><span> </span>
            </p>
            <p>
              <span
                >In this life, she's Bella, a jaded med student trying to catch
                up on centuries of medical innovation. Or at least, she was
                before the Tower appeared. With the promise that she would find
                whatever she sought if she reached the top, she entered, hoping
                to find a way to end her curse.
              </span>
            </p>
            <p>
              <span
                >However, even with hundreds of lives of experience to fall back
                on, reaching the top is no easy task. The Tower is filled with
                wonders she could only dream of, and w</span
              ><span
                >hat she once believed was the peak of power was only the first
                rung of a much larger climb. Her foundations are unshakable, but
                the Tower is deeper, deadlier, and more </span
              ><em><span>exhilarating</span></em
              ><span> than anything she’s ever faced.</span>
            </p>
            <p>
              <span
                >And when she finally reaches the top? She’ll decide whether to
                end it all… or maybe not.</span
              >
            </p>
            <p>
              <span style="text-decoration: underline"
                ><strong>Inspired by:</strong></span
              >
            </p>
            <p>
              - Tower of God<br />- Hunter X Hunter<br />- Hell Difficulty
              Tutorial<br />- Various Murim and Xianxia stories
            </p>
            <p>
              <span style="text-decoration: underline"
                ><strong>What to expect</strong></span
              >
            </p>
            <p>
              <span style="text-decoration: underline"></span>- Strong to
              Stronger<br />- Magic system is Hunter X Hunter + cultivation<br />-
              A Tower of massive scale with many different places and races<br />-
              No romance<br />- Tournament Arc!<br />- Long-term character
              development<br />- A cat (?)
            </p>
          </div>
        </div>
      </div>
    </template>
    <script>
      class RectangleAd {
        static WIDTH = 300;
        static HEIGHT = 250;
        static WIDTH_EXPANDED = 600;

        #state;
        constructor(uid, alt, link) {
          this.#state = {
            position: { x: 0, y: 0 },
            requiredPosition: { x: 0, y: 0 },
            src: `300x250/${uid}.webp`,
            alt,
            link,
            expanded: false,
            imgElem: null,
          };
        }

        get width() {
          return this.#state.expanded
            ? RectangleAd.WIDTH_EXPANDED
            : RectangleAd.WIDTH;
        }
        get height() {
          return this.#state.expanded ? 730 : RectangleAd.HEIGHT;
        }

        get expanded() {
          return this.#state.expanded;
        }

        get currentX() {
          return this.#state.position.x;
        }
        get currentY() {
          return this.#state.position.y;
        }

        get requiredX() {
          return this.#state.requiredPosition.x;
        }
        get requiredY() {
          return this.#state.requiredPosition.y;
        }

        get img() {
          if (this.#state.imgElem === null) {
            this.#state.imgElem = this.#createHTMLElement();

            document
              .querySelector(".rra-grid")
              .appendChild(this.#state.imgElem);
          }
          return this.#state.imgElem;
        }

        get needsPositionUpdate() {
          return (
            this.#state.imgElem === null ||
            this.#state.position.x !== this.#state.requiredPosition.x ||
            this.#state.position.y !== this.#state.requiredPosition.y
          );
        }

        #createHTMLElement() {
          const template = document.getElementById("ad-element");
          const fragment = template.content.cloneNode(true);
          const positioned = fragment.querySelector("div.positioned");
          if (this.#state.expanded) positioned.classList.add("expanded");

          positioned.querySelector("a.ad-wrap").href = this.#state.link;

          // const backdrop = document.createElement("div");
          // backdrop.classList.add("backdrop");
          // backdrop.style.background = `url("${this.#state.src}")`;

          // const img = document.createElement("img");
          const img = positioned.querySelector("a.ad-wrap img");
          img.src = this.#state.src;
          img.alt = this.#state.alt;
          img.title = this.#state.alt;

          // a.replaceChildren(img);

          // positioned.replaceChildren(a);

          return positioned;
        }

        setRequiredPosition(x, y) {
          this.#state.position.x = x;
          this.#state.position.y = y;
        }

        updatePosition() {
          if (!this.needsPositionUpdate) return;
          const { x, y } = this.#state.position;
          this.img.style.transform = `translate(${x}px, ${y}px)`;
        }

        isInViewport(viewportWidth, viewportHeight, scrollY) {}
        setExpanded(val) {
          this.#state.expanded = val;
        }
      }

      class RenderMonkey {
        #state;
        constructor() {
          this.#state = {
            ads: [],
            dirtyAfter: 0,

            varianceCache: new Map(),
          };
        }

        addAdEntries(entries) {
          for (const [uid, entry] of Object.entries(entries))
            this.#state.ads.push(new RectangleAd(uid, entry.alt, entry.link));
          // this.#state.ads[4].setExpanded(true);
        }

        #getVariances(count, variance) {
          if (!this.#state.varianceCache.has(variance))
            this.#state.varianceCache.set(variance, []);

          const variances = this.#state.varianceCache.get(variance);
          const missing = count - variances.length;
          for (let i = 0; i < missing; i += 1) {
            const vx = Math.floor(Math.random() * variance);
            const vy = Math.floor(Math.random() * variance);
            variances.push({ vx, vy });
          }
          return variances;
        }

        updatePosProps(vWidth, vHeight, scrollY) {
          const gap = 10;
          const variance = 40; // TODO: make this dynamic based on vWidth or perRow
          const adWidth = RectangleAd.WIDTH + variance;
          const adHeight = RectangleAd.HEIGHT + variance;

          // Ads

          const n = this.#state.ads.length;
          const variances = this.#getVariances(n, variance);

          // iterator
          const it = {
            y: 0,
            index: 0,
          };

          console.log(n, variances);
          let adsInLastRow = 0;
          let side = null;
          let last_side_position = "right";
          while (it.index < n) {
            // if there was a side but is now over
            if (side && side.tillY < it.y) side = null;

            // if the ad is expanded, we want
            if (this.#state.ads[it.index].expanded) {
              console.log(it.index, "is expanded");
              const ad = this.#state.ads[it.index];
              if (side === null) {
                const { vx, vy } = variances[it.index];
                side = {
                  position: last_side_position === "right" ? "left" : "right",
                  width: ad.width + variance + gap,
                  height: ad.height + variance + gap,
                  tillY: ad.height + vy + gap + it.y,
                  it: Object.assign({}, it),
                };
                const x =
                  side.position === "left"
                    ? vx
                    : vWidth - side.width + gap + vx;
                const y = vy + it.y;
                this.#state.ads[it.index].setRequiredPosition(x, y);
                console.log("side", side);
                it.index += 1;
              } else {
                // if side already exists but this is also expanded
                // handle this
              }
            }

            const avWidth = vWidth - (side?.width ?? 0); // available width
            const adsInRow = Math.floor((avWidth + gap) / (adWidth + gap));
            const adsInThisRow = Math.max(
              1,
              adsInRow - (adsInRow === adsInLastRow)
            );
            adsInLastRow = adsInThisRow;
            const startX =
              Math.floor(
                (avWidth -
                  (adWidth * adsInThisRow + gap * (adsInThisRow - 1))) /
                  2
              ) + (side?.position === "left" ? side.width : 0);
            for (let j = 0; j < adsInThisRow && it.index < n; j += 1) {
              const { vx, vy } = variances[it.index];
              this.#state.ads[it.index].setRequiredPosition(
                vx + startX + j * (adWidth + gap),
                vy + it.y
              );
              it.index += 1;
            }
            it.y += adHeight + gap;
          }
        }

        updatePositions(vWidth, vHeight, scrollY) {
          for (const ad of this.#state.ads) {
            ad.updatePosition();
            // console.log(ad);
          }
        }
      }

      let lastViewportWidth = null;
      let lastViewportHeight = null;
      let lastScrollY = null;
      const renderMonkey = new RenderMonkey();
      const loop = () => {
        const viewportWidth = document.querySelector(".rra-grid").clientWidth;
        const viewportHeight = window.innerHeight;
        const scrollY = window.scrollY;

        // requestAnimationFrame(loop);

        if (
          viewportWidth === lastViewportWidth &&
          viewportHeight === lastViewportHeight &&
          scrollY === lastScrollY
        )
          return;

        lastViewportWidth = viewportWidth;
        lastViewportHeight = viewportHeight;
        lastScrollY = scrollY;
        renderMonkey.updatePosProps(viewportWidth, viewportHeight, scrollY);
        renderMonkey.updatePositions(viewportWidth, viewportHeight, scrollY);
      };

      const handleData = ({ entries }) => {
        renderMonkey.addAdEntries(entries);
        requestAnimationFrame(loop);

        window.addEventListener("resize", loop);
      };

      fetch("300x250/entries.json")
        .then((response) => response.json())
        .then(handleData);
    </script>
  </body>
</html>
